{"compress":true,"commitItems":[["7f029885-2936-4a77-826d-f5b5a81e7185",1518062101297,"## 前言\n\n`Redux`作为`React`的状态管理工具, 在开发大型应用时已不可缺少, 为了更深入的了解`Redux`的整个实现机制, 决定从头开始, 实现实现一个具有基础功能的`Redux`\n\n[项目地址](https://github.com/dj940212/mini-redux)\n\n[预览](http://dj940212.github.io/mini-redux)\n\n## 初始化项目\n\n##### 1.全局安装脚手架\n\n```\nnpm install -g create-react-app\n```\n\n##### 2.创建项目\n\n```\ncreate-react-app mini-redux\n```\n\n##### 3.项目目录\n\n```\nmini-react\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   └── favicon.ico\n│   └── index.html\n│   └── manifest.json\n└── src\n    └── App.css\n    └── App.js\n    └── App.test.js\n    └── index.css\n    └── index.js\n    └── logo.svg\n    └── registerServiceWorker.js\n```\n## 实现Redux基础功能\n\n#### 1.实现Redux\n\n新建`~/src/mini-redux/mini-redux.js`, `redux`会对外暴露一个`createStore`的方法,接受`reducer`作为参数\n\n```js\nexport function createStore(reducer) {\n\tlet currentState = {}\n\tlet currentListeners = []\n\n\tfunction getState() {\n\t\treturn currentState\n\t}\n\tfunction subscribe(listener) {\n\t\tcurrentListeners.push(listener)\n\t}\n\tfunction dispatch(action) {\n\t\tcurrentState = reducer(currentState, action)\n\t\tcurrentListeners.forEach(v => v())\n\t\treturn action\n\t}\n\tdispatch({type: '@REACT_FIRST_ACTION'})  //初始化state\n\treturn { getState, subscribe, dispatch}\n}\n```\n\n以上, 我们就已经实现了`redux`的基础功能, 下面来调用我们实现的`mini-redux`, 检验是否达到预期. 新建`~/src/index.redux.js`\n\n```js\nimport { createStore } from './mini-redux/mini-redux'\n\nconst ADD = 'ADD'\nconst REMOVE = 'REMOVE'\n\n// reducer\nexport function counter(state=0, action) {\n  switch (action.type) {\n    case ADD:\n      \treturn state + 1\n    case REMOVE:\n      \treturn state - 1\n    default:\n      \treturn 10\n  }\n}\n\nexport function add() {\n\treturn {type: 'ADD'}\n}\nexport function remove() {\n\treturn {type: 'REMOVE'}\n}\n\nconst store = createStore(counter)\nconst init = store.getState()\nconsole.log(`开始数值:${init}`)\n\nfunction listener(){\n  const current = store.getState()\n  console.log(`现在数值:${current}`)\n}\n// 订阅，每次state修改，都会执行listener\nstore.subscribe(listener)\n// 提交状态变更的申请\nstore.dispatch({ type: 'ADD' })\nstore.dispatch({ type: 'ADD' })\nstore.dispatch({ type: 'REMOVE' })\nstore.dispatch({ type: 'REMOVE' })\n```\n\n在`index.js`中引入以上文件以执行, 查看控制台,可以看到如下`log`信息\n\n```js\n开始数值:10 \t\t\tindex.redux.js:27\n现在数值:11 \t\t\tindex.redux.js:31 \n现在数值:12 \t\t\tindex.redux.js:31 \n现在数值:11\t\t\t\tindex.redux.js:31 \n现在数值:10\t\t\t\tindex.redux.js:31 \n```\n\n至此,我们已经实现了`redux`的功能, 但是离我们的预期还差的很远, 因为我们需要结合`react`来使用\n\n#### 2.结合React使用\n\n下面将`mini-react`和`react`组件结合使用, 修改`index.redux.js`如下\n\n```js\nconst ADD = 'ADD'\nconst REMOVE = 'REMOVE'\n\n// reducer\nexport function counter(state=0, action) {\n  switch (action.type) {\n    case ADD:\n      \treturn state + 1\n    case REMOVE:\n      \treturn state - 1\n    default:\n      \treturn 10\n  }\n}\n\nexport function add() {\n\treturn {type: 'ADD'}\n}\nexport function remove() {\n\treturn {type: 'REMOVE'}\n}\n```\n\n`index.js`文件初始化`redux`\n\n```jsx\nimport { createStore } from './mini-redux/mini-redux'\nimport { counter } from './index.redux'\n\n// 初始化redux\nconst store = createStore(counter)\n\nfunction render() {\n\tReactDOM.render(<App store={store} />, document.getElementById('root'));\n}\nrender()\n// 每次修改状态,从新渲染页面\nstore.subscribe(render)\n```\n\n`App.js`文件中我们就可以调用`redux`啦\n\n```jsx\nimport {add, remove} from './index.redux'\n\nclass App extends Component {\n    render() {\n        const store = this.props.store\n        // 获取当前值\n        const num = store.getState()\n        return (\n            <div className=\"App\">\n                <p>初始值为{num}</p>\n                <button onClick={() => store.dispatch(add())}>Add</button>\n                <button onClick={() => store.dispatch(remove())}>Remove</button>\n            </div>\n        );\n    }\n}\n\nexport default App;\n```\n\n![](http://ovs5x36k4.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-28%20%E4%B8%8B%E5%8D%883.53.19.png)\n\n如上图, 我们就可以在`React`组件中修改`mini-redux`的状态了\n\n## 实现React-Redux\n\n上面我们已经,实现了`Redux`的功能,并且且可以和`React`结合使用了, 但是这种与`React`的链接的方式非常繁琐,高度耦合, 在日常开发中不会这样用, 我们会使用 `react-redux`库来连接`React`(如果不了解`react-redux`可以看看这篇[博客](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html)), 下面我们就来实现一个简易的`react-redux`\n\n#### 1.context\n\n实现`react-redux`前, 我们要了解一下`react`的 `context`(不了解可以查看[文档](http://www.css88.com/react/docs/context.html)), `react-redux`的实现就利用了`context`机制. 下面通过一个例子,了解`context`的用法.\n\n新建`~/src/mini-redux/context.test.js`\n\n```jsx\nimport React from 'react'\nimport PropTypes from 'prop-types'\n// context是全局的, 组件里声明, 所有子元素可以直接获取\n\nclass Sidebar extends React.Component {\n\trender(){\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<p>Sidebar</p>\n\t\t\t\t<Navbar></Navbar>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nclass Navbar extends React.Component {\n\t// 限制类型, 必须\n\tstatic contextTypes = {\n\t\tuser: PropTypes.string\n\t}\n\trender() {\n\t\tconsole.log(this.context)\n\t\treturn (\n\t\t\t<div>{this.context.user} Navbar</div>\n\t\t)\n\t}\n}\n\n\nclass Page extends React.Component {\n\t// 限制类型, 必须\n\tstatic childContextTypes = {\n\t\tuser: PropTypes.string\n\t}\n\tconstructor(props){\n\t\tsuper(props)\n\t\tthis.state = {user: 'Jack'}\n\t}\n\tgetChildContext() {\n\t\treturn this.state\n\t}\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<p>我是{this.state.user}</p>\n\t\t\t\t<Sidebar/>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default Page\n```\n\n\n#### 2.react-readux\n\n`react-redux`中有两个是我们常用的组件, 分别是`connect`和`Provider`, `connect`用于组件获取`redux`里面的数据(`state`和`action`), `Provider`用于把`store`置于`context`, 让所有的子元素可以获取到`store`, 下面分别实现`connect`和`provider`\n\n##### 实现Provider\n\n新建`~/src/mini-redux/mini-react-redux`, 代码如下\n\n```jsx\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\n\n// 把store放到context里, 所有的子元素可以直接取到store\nexport class Provider extends React.Component{\n\t// 限制数据类型\n  \tstatic childContextTypes = {\n\t\tstore: PropTypes.object\n\t}\n\tgetChildContext(){\n\t\treturn { store:this.store }\n\t}\n\tconstructor(props, context){\n\t\tsuper(props, context)\n\t\tthis.store = props.store\n\t}\n\trender(){\n\t\t// 返回所有子元素\n\t\treturn this.props.children\n\t}\n}\n```\n\n下面验证`Provider`是否能实现预期功能, 修改`~/src/index.js`文件如下\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport { createStore } from './mini-redux/mini-redux'\nimport { Provider } from './mini-redux/mini-react-redux'\nimport { counter } from './index.redux'\n\nconst store = createStore(counter)\n\nReactDOM.render(\n\t(<Provider store={store}><App/></Provider>), \n\tdocument.getElementById('root')\n)\n```\n\n最后我们还要修改`~/src/App.js`文件中获取`store`数据的方式, 改成使用`connect`获取, 但是因为还没有实现`connect`, 所有我们暂使用原`react-redux`的`connect`组件验证上面实现的`Provider`\n\n```jsx\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux'\nimport {add, remove} from './index.redux'\n\nclass App extends Component {\n    render() {\n        return (\n            <div className=\"App\">\n                <p>初始值为{this.props.num}</p>\n                <button onClick={this.props.add}>Add</button>\n                <button onClick={this.props.remove}>Remove</button>\n            </div>\n        );\n    }\n}\n\nApp = connect(state => ({num: state}), {add, remove})(App)\n\nexport default App;\n```\n\n 验证结果, 上面实现的`Provider`成功对接`connect`\n\n##### 实现connect\n\n上面我们实现了`Provider`, 但是`connect`仍然用的是原版`react-redux`的`connect`, 下面就来在`~/src/mini-redux/mini-react-redux.js`文件中添加一个`connect`方法\n\n```jsx\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport {bindActionCreators} from './mini-redux'\n\n// connect 负责链接组件，给到redux里的数据放到组件的属性里\n// 1. 负责接受一个组件，把state里的一些数据放进去，返回一个组件\n// 2. 数据变化的时候，能够通知组件\n\nexport const connect = (mapStateToProps = state=>state, mapDispatchToProps = {}) => (WrapComponent) => {\n\treturn class ConnectComponent extends React.Component{\n\t\tstatic contextTypes = {\n\t\t\tstore:PropTypes.object\n\t\t}\n\t\tconstructor(props, context){\n\t\t\tsuper(props, context)\n\t\t\tthis.state = {\n\t\t\t\tprops:{}\n\t\t\t}\n\t\t}\n\t\tcomponentDidMount(){\n\t\t\tconst {store} = this.context\n\t\t\tstore.subscribe(()=>this.update())\n\t\t\tthis.update()\n\t\t}\n\t\tupdate(){\n\t\t\t// 获取mapStateToProps和mapDispatchToProps 放入this.props里\n\t\t\tconst {store} = this.context\n\t\t\tconst stateProps = mapStateToProps(store.getState())\n\t\t\t// 方法不能直接给，因为需要dispatch\n\t\t\tconst dispatchProps = bindActionCreators(mapDispatchToProps, store.dispatch)\n\t\t\tthis.setState({\n\t\t\t\tprops:{\n\t\t\t\t\t...this.state.props,\n\t\t\t\t\t...stateProps,\n\t\t\t\t\t...dispatchProps\t\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\trender(){\n\t\t\treturn <WrapComponent {...this.state.props}></WrapComponent>\n\t\t}\n\t}\n}\n```\n\n在上面代码中, 我们还需要在`mini-redux.js`中添加一个`bindActionCreators`方法, 用于使用`dispatch`包裹包裹`actionCreator`方法, 代码如下\n\n```jsx\n......\nfunction bindActionCreator(creator, dispatch){\n\treturn (...args) => dispatch(creator(...args))\n}\nexport function bindActionCreators(creators,dispatch){\n\tlet bound = {}\n\tObject.keys(creators).forEach(v=>{\n\t\tlet creator = creators[v]\n\t\tbound[v] = bindActionCreator(creator, dispatch)\n\t})\n\treturn bound\n}\n......\n```\n\n最后我们将`~/src/App.js`中的`connect`换成上面完成的`connect`, 完成测试\n\n```js\nimport { connect } from './mini-redux/mini-react-redux'\n```\n\n## 实现redux中间件机制\n\n#### 实现applyMiddleware\n\n在平常使用`redux`时, 我们会利用各种中间件来扩展`redux`功能, 比如使用`redux-thunk`实现异步提交`action`, 现在来给我们的`mini-redux`添加中间件机制\n\n修改`~/src/mini-redux/mini-redux.js`代码如下\n\n```js\nexport function createStore(reducer, enhancer) {\n\tif (enhancer) {\n\t\treturn enhancer(createStore)(reducer)\n\t}\n\t\n\tlet currentState = {}\n\tlet currentListeners = []\n\n\tfunction getState() {\n\t\treturn currentState\n\t}\n\tfunction subscribe(listener) {\n\t\tcurrentListeners.push(listener)\n\t}\n\tfunction dispatch(action) {\n\t\tcurrentState = reducer(currentState, action)\n\t\tcurrentListeners.forEach(v => v())\n\t\treturn action\n\t}\n\t//初始化state\n\tdispatch({type: '@REACT_FIRST_ACTION'})\n\treturn { getState, subscribe, dispatch}\n}\n\nexport function applyMiddleware(middleware) {\n\treturn createStore => (...args) => {\n\t\tconst store = createStore(...args)\n\t\tlet dispatch = store.dispatch\n\n\t\tconst midApi = {\n\t\t\tgetState: store.getState,\n\t\t\tdispatch: (...args) => dispatch(...args)\n\t\t}\n\t\tdispatch = middleware(midApi)(store.dispatch)\n\n\t\treturn {\n\t\t\t...store,\n\t\t\tdispatch\n\t\t}\n\n\t} \n}\n......\n```\n\n以上我们就给`mini-redux`添加了中间件机制了, 下面我们就来使用中间件, 进行验证. 由于我们开没有自己的中间件, 现在使用`redux-thunk`来实现一个异步提交`action`\n\n修改`~/src/index.js`\n\n```jsx\n......\nimport { createStore, applyMiddleware } from './mini-redux/mini-redux'\nimport thunk from 'redux-thunk'\n\nconst store = createStore(counter, applyMiddleware(thunk))\n......\n```\n\n修改`~/src/index.redux.js`, 添加一个异步方法\n\n```js\nexport function addAsync() {\n    return dispatch => {\n    setTimeout(() => {\n        dispatch(add());\n    }, 2000);\n  };\n}\n```\n\n最后我们要`~/src/App.js`中引入这个异步方法, 修改如下\n\n```js\n......\nimport React, { Component } from 'react';\nimport { connect } from './mini-redux/mini-react-redux'\nimport {add, remove, addAsync} from './index.redux'\n\nclass App extends Component {\n    render() {\n        return (\n            <div className=\"App\">\n                <p>初始值为{this.props.num}</p>\n                <button onClick={this.props.add}>Add</button>\n                <button onClick={this.props.remove}>Remove</button>\n                <button onClick={this.props.addAsync}>AddAsync</button>\n            </div>\n        );\n    }\n}\n\nApp = connect(state => ({num: state}), {add, remove, addAsync})(App)\nexport default App;\n```\n\n然后就可以验证啦\n\n#### 实现redux中间件\n\n上面我们使用了`redux-thunk`中间件, 为何不自己写一个呢\n\n新建`~/src/mini-redux/mini-redux-thunk.js`\n\n```js\nconst thunk = ({dispatch, getState}) => next => action => {\n\t// 如果是函数，执行一下，参数是dispatch和getState\n\tif (typeof action=='function') {\n\t\treturn action(dispatch,getState)\n\t}\n\t// 默认，什么都没干，\n\treturn next(action)\n}\nexport default thunk\n```\n\n将`~/src/index.js`中的`thunk`换成上面实现的`thunk`, 看看程序是否还能正确运行\n\n在上面的基础上, 我们再实现一个`arrThunk`中间件, 中间件提供提交一个`action`数组的功能\n\n新建`~/src/mini-redux/mini-redux-arrayThunk.js`\n\n```js\nconst arrayThunk = ({dispatch,getState})=>next=>action=>{\n\tif (Array.isArray(action)) {\n\t\treturn action.forEach(v=>dispatch(v))\n\t}\n\treturn next(action)\n}\nexport default arrayThunk\n```\n\n\n\n#### 添加多个中间件处理\n\n上面我们实现的中间件机制,只允许添加一个中间件, 这不能满足我们日常开发的需要\n\n修改`~/src/mini-redux/mini-redux.js`文件\n\n```js\n......\n// 接收中间件\nexport function applyMiddleware(...middlewares) {\n\treturn createStore => (...args) => {\n\t\tconst store = createStore(...args)\n\t\tlet dispatch = store.dispatch\n\n\t\tconst midApi = {\n\t\t\tgetState: store.getState,\n\t\t\tdispatch: (...args) => dispatch(...args)\n\t\t}\n\t\tconst middlewareChain = middlewares.map(middleware=>middleware(midApi))\n\t\tdispatch = compose(...middlewareChain)(store.dispatch)\n\n\t\treturn {\n\t\t\t...store,\n\t\t\tdispatch\n\t\t}\n\n\t} \n}\n// compose(fn1,fn2,fn3)  ==> fn1(fn2(fn3))\nexport function compose(...funcs){\n\tif (funcs.length==0) {\n\t\treturn arg=>arg\n\t}\n\tif (funcs.length==1) {\n\t\treturn funcs[0]\n\t}\n\treturn funcs.reduce((ret,item)=> (...args)=>ret(item(...args)))\n}\n......\n```\n\n最后我们将之前实现的两个中间件`thunk`,`arrThunk`同时使用, 看看上面实现的多中间件合并是否完成\n\n修改`~/src/index.js`\n\n```js\n...\nimport arrThunk from './mini-redux/mini-redux-arrThunk'\nconst store = createStore(counter, applyMiddleware(thunk, arrThunk))\n...\n```\n\n在`~/src/index.redux.js`中添加一个`addTwice` action生成器\n\n```js\n...\nexport function addTwice() {\n  return [{type: 'ADD'}, {type: 'ADD'}]\n}\n...\n```\n\n`~/src/App.js`中增加一个`addTwice`的按钮, 修改相应代码\n\n```js\nimport {add, remove, addAsync, addTwice} from './index.redux'\n\nclass App extends Component {\n    render() {\n        return (\n            <div className=\"App\">\n                <p>now num is {this.props.num}</p>\n                <button onClick={this.props.add}>Add</button>\n                <button onClick={this.props.remove}>Remove</button>\n                <button onClick={this.props.addAsync}>AddAsync</button>\n                <button onClick={this.props.addTwice}>addTwice</button>\n            </div>\n        );\n    }\n}\n\nApp = connect(state => ({num: state}), {add, remove, addAsync, addTwice})(App)\n```\n\n大功告成!\n\n![](http://ovs5x36k4.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-29%20%E4%B8%8B%E5%8D%882.59.52.png)",[[1518062101188,["ding@air.local",[[1,0,"---\nstyle: summer\n---\n"]],[11385,11385],[11407,11407]]],[1518062102723,["ding@air.local",[[-1,11,"summer"],[1,17,"plain"]],[11407,11407],[11406,11406]]],[1518062103870,["ding@air.local",[[-1,11,"plai"],[1,15,"ocea"]],[11406,11406],[11406,11406]]],[1518062106525,["ding@air.local",[[-1,11,"o"],[-1,13,"e"],[1,16,"dy"]],[11406,11406],[11406,11406]]],[1518062107869,["ding@air.local",[[-1,0,"---\nstyle: candy\n---\n"]],[11406,11406],[11385,11385]]],[1518062108845,["ding@air.local",[[1,0,"---\nstyle: candy\n---\n"]],[11385,11385],[11406,11406]]],[1518062109885,["ding@air.local",[[1,11,"o"],[1,12,"e"],[-1,14,"dy"]],[11406,11406],[11406,11406]]]]]]}